## Creating Go Routines

### Synchronization vs. Orchestration

- **Synchronization**: Goroutines wait in line to take turns (e.g., waiting to speak to a barista at a coffee shop).
- **Orchestration**: Interaction between goroutines (e.g., ordering coffee and exchanging money with the barista).

#### Synchronization Primitives:

- **Timers:** Used to manage timing-related waits.
- **Mutexes:** Ensure that only one goroutine accesses a shared resource at a time.

#### Orchestration Primitives:

**Channels:** Facilitate communication and coordination between multiple goroutines.

#### Guidelines

- Always use the correct primitive for the problem at hand to avoid unnecessary complexity.
- Avoid using orchestration tools like channels for synchronization tasks and vice versa to maintain clarity and efficiency in code.

### Example 1

Consider the following code that demonstrates how to create Go Routines using `sync.Waitgroup`:

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

func init() {
	runtime.GOMAXPROCS(1)
}

func hello() {
	for range 10 {
		fmt.Println("Called hello")
	}
}

func goodbye() {
	for range 10 {
		fmt.Println("Called goodbye")
	}
}

func main() {
	// wg is used to manage concurrency
	var wg sync.WaitGroup
	wg.Add(2)

	fmt.Println("starting goroutines")

	// create a goroutine that calls hello
	go func() {
		hello()
		wg.Done()
	}()

	// create a goroutine that calls goodbye
	go func() {
		goodbye()
		wg.Done()
	}()

	// wait for the goroutines to finish
	fmt.Println("\ndone starting, waiting to finish:")
	wg.Wait()

	fmt.Println("\nfinished, terminating")
}
```

### Example 2


