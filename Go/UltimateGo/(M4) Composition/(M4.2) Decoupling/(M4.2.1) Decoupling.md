## Decoupling

### Preface

It's important to always start by drafting code; it shouldn't be perfect right off the bat.

With the following program, we will

- Employ all the mechanics and semantics we've learned. 
- Demonstrate one of Rob Pike's biggest philosophies in Go, _discovering_ our interfaces.
- Observe how to write code in well-defined layers

### Scenario

A client has an old system, `Xenia`, that uses a proprietary database containing valuable data. Their modern money-making system, `Pillar`, uses a more traditional database and extends better APIs. How can we move the valuable data from the Xenia to Pillar?

#### Breaking it Down

The main focuses with the task are:

1. Connecting to the `Xenia` proprietary database
2. Identifying the data within Xenia and moving it out
3. Connecting to the `Pillar` database
4. Storing the `Xenia` data into the `Pillar` database

These are _primitive_ problems and we should prototype each of them.

- First, we need to build an API to solve the primitive problems.
- Second, we need to build a low-level API on top of this
- Third, we need to build a high-level API on top of this

#### Primitive Layer

Let's focus on structuring instead of implementation within our primitive layer:

```go
package main

import (
  "errors"
  "fmt"
  "io"
  "math/rand"
  "time"
)

// Data is the structure of the data we are copying
type Data struct {
  Line string
}

// Xenia is a system we need to pull data from
type Xenia struct {
  Host string
  Timeout time.Duration
}

// Pull knows how to pull data out of Xenia
func (*Xenia) Pull(d *Data) error {
  switch rand.Intn(10) {
  case 1, 9:
    return io.EOF
  case 5:
    return errors.New("Error reading data")
  default:
    d.Line = "Data"
    fmt.Println("In:", d.Line)
    return nil
  }
}

// Pillar is a system we need to store data into
type Pillar struct {
  Host string
  Timeout time.Duration
}

// Store knows how to store data into Pillar
func (p *Pillar) Store(d *Data) error {
  fmt.Println("Out:", d.Line)
  return nil
}
```

Because this is our first draft of code:

- Ignore overwhelming yourself with questions like "Are we really going to call `Pull` for every single piece of data we have?"
- We don't care about optimizing this primitive problem for performance, only for correctness.

With our primitive layer in place, we can move on to our low-level layer: 

### Low-Level Layer

When we start thinking about our low-level API, we see that we have two systems with two unique behaviors, so we might want to create a new concrete type called `System` that can hold them. It will get its behavior from the embedding of our concrete types:

```go
// System wraps Xenia and Pillar together into a single system
type System struct {
  Xenia
  Pillar
}
```


This isn't necessarily the ultimate solution for composition, it's just something that works. 

> [!Note]
>
> Our code should use functions as much as possible while it's reasonable/practical to do so. 

We used a method-based API for `Xenia` and `Pillar` since they're state. Now, we'll use a function-based API in our lower level.

Let's create a function `pull` to pull bulk data from `Xenia`:

```go
// pull knows how to pull bulks of data from Xenia
func pull(x *Xenia, data []Data) (int, error) {
  for i := range data {
    err := x.Pull(&data[i]); 
    if err != nil {
      return i, err
    }
  }
  return len(data), nil
}
```

Similarly, we can create a `store` function:

```go
// store knows how to store bulks of data into Pillar
func store(p *Pillar, data []Data) (int, error) {
  for i := range data {
    err := p.Store(&data[i])
    if err != nil {
      return i, err
    }
  }
  return len(data), nil
}
```

This is our first implementation of our low-level API in place.

### High-Level Layer

Now, we can leverage one singular function that uses these `pull` and `store` functions. Notice the pattern to the layering?

We'll call it `Copy`:

```go
func Copy(sys *System, batch int) error {
  data := make([]Data, batch)

  for {
    i, err := pull(&sys.Xenia, data)
    if i > 0 {
      _, err := store(&sys.Pillar, data)
      if err != nil {
        return err
      }
    }

    if err != nil {
      return err
    }
  }
}
```
Notice in the signature

```go
func Copy(sys *System, batch int) error {...}
```

this function accepts a `*System`, which lets us use our `pull` and `store` behaviors from `Xenia` and `Pillar`. It also accepts `batch`, a batch size. The first line of our body is

```go
data := make([]Data, batch)
```

We can see its value isn't known at runtime, meaning that it will be constructed on the heap, but it won't hurt us.

Then, we create an infinite loop and use `pull` and `store` with our systems and check for errors.

### `main`

Within `main`, we can setup these systems and interact with them:

```go
func main() {
  sys := System{
    Xenia: Xenia{
      Host: "localhost:8080",
      Timeout: time.Second,
    },
    Pillar: Pillar{
      Host: "localhost:9090",
      Timeout: time.Second,
    },
  }

  err := Copy(&sys, 3)
  if err != io.EOF {
    fmt.Println(err)
  }
}
```

This first concrete implementation is fast enough, tested and therefore production-ready, but we're not done.

### What Now?

It's important to understand what "done" really means:

- **Test Coverage:** While our ultimate gaol is 100% test coverage, we can think of it as at least 70% test coverage for now.
- **Implementation:** We should evaluate our concrete implementation and foresee any changes that will be made.

What events might show up that require change?

What if our client tells us they have two new projects:

- `Apollo`, which needs its DB data migrated over to `Pillar` and
- `Dream`, which is a server similar to `Pillar`, and needs data from `Xenia` and `Apollo`?

In this case, our systems are going to change. Let's decouple our program by doing a bit of discovery.
