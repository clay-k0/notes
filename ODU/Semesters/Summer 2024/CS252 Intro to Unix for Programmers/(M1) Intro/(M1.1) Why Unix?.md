## Why Unix?

- Unix behavior explains why the CS department uses it.
- Compare Unix with Windows to understand its fundamentals.
- Look at the history of CPUs, display technology, and network technology.

## Evolution of CPUs

- Mainframes were large and power-hungry.
- Early systems ran only one program at a time.
- Multiprocessing and multiprogramming evolved to run multiple programs simultaneously.
- Unix was designed to support these features from the start.

## Display Technology

- Early computers used punch cards and printers.
- Multiprocessing led to the use of computer terminals with CRT screens.
- Terminals were expensive and used different control sequences.
- Microprocessors reduced costs, leading to PCs with network capabilities.

## Network Technology

- The Internet allowed remote access to mainframes.
- UseNet and local networks advanced networking.
- Unix was designed with networking in mind, allowing remote machine control.

## Unix vs. MSDOS and Windows

- **Unix**: Multiprocessing, hardware safeguards, compatible with various terminals, networking standard.
- **MSDOS/Windows**: Initially single-user, single-process, limited networking.
- Windows evolved but never matched Unix's protection and stability.

## The Philosophy of Unix

- Unix users type commands instead of relying on GUIs.
- Text-based applications combined through pipelines.
- Emphasis on remote access and modularity.

## Practical Reasons for Using Unix in CS

- Easy installation and maintenance across multiple machines.
- Consistency and remote access are crucial in academic environments.

## Is Unix Still Relevant?

- Unix is continually evolving and widely used.
- Many modern OSes (OS/X, iOS, Android) are Unix-based.
- Understanding Unix is essential for computing professionals.
